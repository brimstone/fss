#!/bin/sh
set -ue
command_exists () {
	command -v "$@" >/dev/null 2>&1
}
DEBUG=1
package () {
	NAME=""
	VERSION=""
	usage="Error calling packages:
package \"name\"
         -or-
package --name     \"name\"         \\
        --file     \"path/to/file\" \\
        --version  \"version\"      \\
        --apt                     \\
        --yum
"
	# Too few args
	if [ $# -lt 2 ]; then
		echo "Too few arguments"
		echo "$usage"
		return 1
	# First case
	elif [ $# = 2 ]; then
		SRC="$1"
		DIST="$2"
	# Remaining cases
	else
		while [ $# -gt 0 ]; do
			case "$1" in 
				--src)
					shift
					SRC="$1"
				;;
				--dist)
					shift
					DIST="$1"
				;;
				--mode)
					shift
					MODE="$1"
				;;
				--user)
					shift
					CHUSER="$1"
				;;
				--group)
					shift
					CHGROUP="$1"
				;;
				*)
					echo "Unknown option: $1"
					echo "$usage"
					return 1
				;;
			esac
			shift
		done
	fi
	# Check to make sure something set our required variables
	if [ -z "$SRC" ]; then
		echo "Missing SRC"
		echo "$usage"
		return 1
	fi
	if [ -z "$DIST" ]; then
		echo "Missing DIST"
		echo "$usage"
		return 1
	fi
	# Actually do the magic
	(
		echo "cat <<DOG"
		cat "$SRC"
		echo "DOG"
	) | sh > "$DIST"
	# Post creation tasks
	if [ -n "$MODE" ]; then
		if command -v chmod >/dev/null; then
			chmod "$MODE" "$DIST"
		else
			echo "No such command chmod"
			return 1
		fi
	fi
	if [ -n "$CHUSER" ]; then
		if command -v chown >/dev/null; then
			chown "$CHUSER" "$DIST"
		else
			echo "No such command chown"
			return 1
		fi
	fi
	if [ -n "$CHGROUP" ]; then
		if command -v chgrp >/dev/null; then
			chgrp "$CHGROUP" "$DIST"
		else
			echo "No such command chgrp"
			return 1
		fi
	fi
}
template () {
	SRC=""
	DEST=""
	MODE=""
	CHUSER=""
	CHGROUP=""
	usage="Error calling template:
template \"srcfile\" \"dest\"
         -or-
template --src   \"srcfile\"  \\
         --dist  \"distfile\" \\
         --mode  755        \\
         --user  root       \\
         --group root
"
	# Too few args
	if [ $# -lt 2 ]; then
		echo "Too few arguments"
		echo "$usage"
		return 1
	# First case
	elif [ $# = 2 ]; then
		SRC="$1"
		DIST="$2"
	# Remaining cases
	else
		while [ $# -gt 0 ]; do
			case "$1" in 
				--src)
					shift
					SRC="$1"
				;;
				--dist)
					shift
					DIST="$1"
				;;
				--mode)
					shift
					MODE="$1"
				;;
				--user)
					shift
					CHUSER="$1"
				;;
				--group)
					shift
					CHGROUP="$1"
				;;
				*)
					echo "Unknown option: $1"
					echo "$usage"
					return 1
				;;
			esac
			shift
		done
	fi
	# Check to make sure something set our required variables
	if [ -z "$SRC" ]; then
		echo "template: Missing SRC"
		echo "$usage"
		return 1
	fi
	if [ -z "$DIST" ]; then
		echo "template: Missing DIST"
		echo "$usage"
		return 1
	fi
	[ $DEBUG -gt 0 ] && echo "template called: '$SRC' '$DIST'"
	# Actually do the magic
	(
		echo "cat <<DOG"
		cat "$SRC"
		echo "DOG"
	) | sh > "$DIST"
	# Post creation tasks
	if [ -n "$MODE" ]; then
		if command_exists chmod; then
			chmod "$MODE" "$DIST"
		else
			echo "No such command chmod"
			return 1
		fi
	fi
	if [ -n "$CHUSER" ]; then
		if command_exists chown; then
			chown "$CHUSER" "$DIST"
		else
			echo "No such command chown"
			return 1
		fi
	fi
	if [ -n "$CHGROUP" ]; then
		if command_exists chgrp; then
			chgrp "$CHGROUP" "$DIST"
		else
			echo "No such command chgrp"
			return 1
		fi
	fi
}
trap "run_fss $@" EXIT
run_fss_file() {
	if [ ! -f "$1" ]; then
		echo "$1 not a file"
		exit 1
	fi
	[ $DEBUG -gt 0 ] && echo "==> Running $1"
	(
		cd "${1%/*}"
		. "./${1##*/}"
	)
}
run_fss_directory() {
	if [ ! -d "$1" ]; then
		return 1
	fi
	[ $DEBUG -gt 0 ] && echo "==> Running all in $1"
	for s in "$1"/*; do
		[ -f "$s" ] && run_fss_file "$s" || :
	done
}
run_fss() {
	tail -n 1 "$0" | grep -q "^ # FSS Last Line Marker$" || return
	if [ $# = 0 ]; then
		if ! run_fss_directory "scripts"; then
			echo "ERROR: scripts directory missing and no scripts passed via cmdline!" >&2
			exit 1
		fi
	else
		while [ $# -gt 0 ]; do
			[ -d "$1" ] && run_fss_directory "$1" || :
			[ -f "$1" ] && run_fss_file "$1" || :
			shift
		done
	fi
}
 # FSS Last Line Marker
